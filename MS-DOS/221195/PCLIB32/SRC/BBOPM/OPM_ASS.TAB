; ************
; * NAME     : DSA_ASS.asm
; * AUTOR    : Viper, BlueByte
; * START    : 25.05.94 14:00
; * PROJECT  : Poject32/Macintosh
; * NOTES    :
; * SEE ALSO :
; * VERSION  : 1.0
; ************/

	.386p

	ASSUME DS:OPM_DATA

	.MODEL FLAT
	.CODE

; Public Functions
	PUBLIC	C OPM_ASS_FillBlock_ 					; gefÅllter Block
	PUBLIC	C OPM_ASS_VerLine_ 						; vertikale Linie
	PUBLIC	C OPM_ASS_HorLine_ 						; horizontale Linie
	PUBLIC	C OPM_ASS_ChangeCol_ 						; horizontale Linie
	PUBLIC	C OPM_ASS_Zoom_ 						; horizontale Linie
	PUBLIC	C OPM_ASS_Blit_ 									; Datenbereiche mit Modulo kopieren
	PUBLIC	C OPM_ASS_Blit_Trans_ 									; Datenbereiche mit Modulo kopieren

; Public Variablen
	PUBLIC	_ZOOM_DESTCLIPX0 ; Clipping Variablen fÅr ZoomBob
	PUBLIC	_ZOOM_DESTCLIPY0
	PUBLIC	_ZOOM_DESTCLIPX1
	PUBLIC	_ZOOM_DESTCLIPY1

; externe Variablen
;	extrn	_lastpage:WORD ; letze eingeschaltete Page

; Include Files
	INCLUDE ..\..\LIB\ASMINC\BBMACRO.INC
	INCLUDE ..\..\LIB\ASMINC\BBHARD.INC

OPM	SEGMENT PARA USE32 'CODE'	;

;PROCEDURE OPM_ASS_FILLBLOCK_
;******************************************************************************
;* #FUNCTION HEADER BEGIN#
;* NAME      : OPM_ASS_FILLBLOCK_
;* FUNCTION  : FÅllt Block Farbe
;*
;* INPUTS    : UNBYTE *dest(EDI): ZIEL
;*					SILONG mod(EDX); Modulo
;*					UNLONG width(ESI): Breite
;*					UNLONG height(EBX): Hîhe
;*					UNLONG color(EAX): Farbe
;*
;* RESULT    :
;*
;* FILE      : OPM_ASS.ASM
;* AUTHOR    : VIPER
;* FIRST     : 22.07.94 14:30:12
;* LAST      : 12.08.94 16:09:44
;* BUGS      :
;* NOTES     :
;* SEE ALSO  :
;* VERSION   : 0.1
;* #FUNCTION HEADER END#

OPM_ASS_FillBlock_ PROC C

	mov 	AH,AL
	shl 	EAX,8
	mov 	AL,AH
	shl 	EAX,8
	mov 	AL,AH ; Farbe auf Langwort

	cmp 	ESI,8  ; Breite<8, dann in die 1-Chunk-Routine
	jl 	LOCALONE_CHUNK_LINE

	test EDI,1
	jne 	@DI01
	test EDI,2
	jne 	@DI10

	shr 	ESI,1
	jb 	@00CX01
	shr 	ESI,1
	jb 	@00CX10

@@:
	mov 	ECX,ESI
	rep 	STOSD

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@00CX10:

	add 	EDX,2
@@:
	mov 	ECX,ESI
	rep 	STOSD
	mov 	[EDI],AX

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@00CX01:
	shr 	ESI,1
	jb 	@00CX11

	inc	EDX
@@:
	mov 	ECX,ESI
	rep 	STOSD
	mov 	[EDI],AL

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@00CX11:

	add 	EDX,3
@@:
	mov 	ECX,ESI
	rep 	STOSD
	mov 	[EDI],AX
	mov 	2[EDI],AL

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@DI10:
	shr 	ESI,1
	jb 	@10CX01
@10CX00:
	shr 	ESI,1
	jb 	@10CX10

	add	EDX,2
	dec	ESI
@@:
	mov 	ECX,ESI
	mov 	[EDI],AX
	add 	EDI,2
	rep 	STOSD
	mov 	[EDI],AX

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@10CX10:

@@:
	mov 	ECX,ESI
	mov 	[EDI],AX
	add 	EDI,2
	rep 	STOSD

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@10CX01:
	shr 	ESI,1
	jb 	@10CX11

	add	EDX,3
	dec	ESI
@@:
	mov 	ECX,ESI
	mov 	[EDI],AX
	add 	EDI,2
	rep 	STOSD
	mov 	[EDI],AX
	mov 	2[EDI],AL

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@10CX11:

	inc	EDX
@@:
	mov 	ECX,ESI
	mov 	[EDI],AX
	add 	EDI,2
	rep 	STOSD
	mov 	[EDI],AL

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@DI01:
	test EDI,2
	jne 	@DI11

	shr 	ESI,1
	jb 	@00CX01
@01CX00:
	shr 	ESI,1
	jb 	@00CX10

	inc	EDX
	dec	ESI
@@:
	mov 	ECX,ESI
	mov 	[EDI],AL
	mov 	1[EDI],AX
	add 	EDI,3
	rep 	STOSD
	mov 	[EDI],AL

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@01CX10:

	add	EDX,3
	dec	ESI
@@:
	mov 	ECX,ESI
	mov 	[EDI],AL
	mov 	1[EDI],AX
	add 	EDI,3
	rep 	STOSD
	mov 	[EDI],AX
	mov 	2[EDI],AL

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@01CX01:
	shr 	ESI,1
	jb 	@00CX10

	add	EDX,2
	dec	ESI
@@:
	mov 	ECX,ESI
	mov 	[EDI],AL
	mov 	1[EDI],AX
	add 	EDI,3
	rep 	STOSD
	mov 	[EDI],AX

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@01CX11:

@@:
	mov 	ECX,ESI
	mov 	[EDI],AL
	mov 	1[EDI],AX
	add 	EDI,3
	rep 	STOSD

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@DI11:
	shr 	ESI,1
	jb 	@11CX01
@11CX00:
	shr 	ESI,1
	jb 	@11CX10

	add	EDX,3
	dec	ESI
@@:
	mov 	ECX,ESI
	mov 	[EDI],AL
	inc 	EDI
	rep 	STOSD
	mov 	[EDI],AX
	mov 	2[EDI],AL

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@11CX10:

	inc	EDX
@@:
	mov 	ECX,ESI
	mov 	[EDI],AL
	inc 	EDI
	rep 	STOSD
	mov 	[EDI],AL

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@11CX01:
	shr 	ESI,1
	jb 	@11CX11

@@:
	mov 	ECX,ESI
	mov 	[EDI],AL
	inc 	EDI
	rep 	STOSD

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

@11CX11:

	add	EDX,2
@@:
	mov 	ECX,ESI
	mov 	[EDI],AL
	inc 	EDI
	rep 	STOSD
	mov 	[EDI],AX

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret

LOCALONE_CHUNK_LINE:

@@:
	mov	ECX,ESI
	rep 	STOSB

	add	EDI,EDX ; Modulo

	dec 	EBX
	jg 	@B

	ret
OPM_ASS_FillBlock_ ENDP

;PROCEDURE OPM_ASS_VerLine_
;******************************************************************************
;* #FUNCTION HEADER BEGIN#
;* NAME      : OPM_ASS_VerLine_
;* FUNCTION  : Zeichnet vertikale Linie
;*
;* INPUTS    : UNBYTE *dest(EDI): ZIEL
;*					SILONG mod(EDX); Modulo
;*					UNLONG height(EBX): Hîhe
;*					UNLONG color(EAX): Farbe
;*
;* RESULT    :
;*
;* FILE      : OPM_ASS.ASM
;* AUTHOR    : VIPER
;* FIRST     : 22.07.94 14:30:12
;* LAST      : 09.11.94 13:34:52
;* BUGS      :
;* NOTES     :
;* SEE ALSO  :
;* VERSION   : 0.1
;* #FUNCTION HEADER END#

OPM_ASS_VerLine_ PROC C

	shl	EBX,2
	add 	EBX,VERJMPTABLE
	jmp 	[EBX]
VERLABELNUM = (MAXSCREENHEIGHT_PCLIB)-1
	repeat MAXSCREENHEIGHT_PCLIB  ; Macro generiert 640/2 eintrÑge mit Label
	VERLABEL CATSTR <VERLAB>,%VERLABELNUM
	mov	[EDI],AL
	add 	EDI,EDX
%VERLABEL:
	VERLABELNUM = VERLABELNUM - 1
	ENDM

	ret


OPM_ASS_VerLine_ ENDP

					ALIGN 4
; Sprungtabelle fÅr Langworte normales TexturePolygon
VERJMPTABLE:
	VERLABELNUM = 0
	REPEAT MAXSCREENHEIGHT_PCLIB
	VERLABEL	CATSTR <VERLAB>,%VERLABELNUM
	DD VERLABEL
	VERLABELNUM = VERLABELNUM + 1
	ENDM


;PROCEDURE OPM_ASS_HorLine_
;******************************************************************************
;* #FUNCTION HEADER BEGIN#
;* NAME      : OPM_ASS_HorLine_
;* FUNCTION  : FÅllt Block Farbe
;*
;* INPUTS    : UNBYTE *dest(EDI): ZIEL
;*					SILONG mod(EDX); Modulo
;*					UNLONG width(EBX): Breite
;*					UNLONG color(EAX): Farbe
;*
;* RESULT    :
;*
;* FILE      : OPM_ASS.ASM
;* AUTHOR    : VIPER
;* FIRST     : 22.07.94 14:30:12
;* LAST      : 09.11.94 14:02:44
;* BUGS      :
;* NOTES     :
;* SEE ALSO  :
;* VERSION   : 0.1
;* #FUNCTION HEADER END#

OPM_ASS_HorLine_ PROC C

	cmp 	EBX,12  ; Breite<8, dann in die 1-Chunk-Routine
	jl 	HorLineSmall

	mov 	AH,AL
	mov	CX,AX
	shl 	EAX,16
	mov	AX,CX ; Farbe auf Langwort

	mov	ECX,EDI
	neg	ECX
	and	ECX,3
	sub	EBX,ECX
	rep 	STOSB ; dword align

	mov 	ECX,EBX
	shr 	ECX,2  ; Anzahl/4
	rep 	STOSD  ; 4 Pixel auf einmal schreiben

	mov 	ECX,EBX
	and 	ECX,3
	rep 	STOSB

	ret
HorLineSmall:

	mov 	ECX,EBX
	rep 	STOSB

	ret
OPM_ASS_HorLine_ ENDP


;PROCEDURE OPM_ASS_ChangeCol_
;******************************************************************************
;* #FUNCTION HEADER BEGIN#
;* NAME      : OPM_ASS_ChangeCol_
;* FUNCTION  : éndert die Farbe eines Bereiches anhand einer FarbIndexTabelle
;*
;* INPUTS    : UNBYTE *dest(EDI): ZIEL
;*					UNBYTE *mod(ESI); Zeiger auf 256 Byte Tabelle
;*					SILONG mod(EBX); Modulo
;*					UNLONG width(ECX): Breite
;*					UNLONG height(EDX): Hîhe
;*
;* RESULT    :
;*
;* FILE      : OPM_ASS.ASM
;* AUTHOR    : VIPER
;* FIRST     : 22.07.94 14:30:12
;* LAST      : 11.11.94 15:30:09
;* BUGS      :
;* NOTES     : Es wird eine optimierte Version verwendet wenn die Tabelle an einer
;*					256 Byte Grenze liegt ca 1.5 mal so schnell
;* SEE ALSO  :
;* VERSION   : 0.1
;* #FUNCTION HEADER END#

OPM_ASS_ChangeCol_ PROC C USES EBP

	xor	EAX,EAX ; eax Longwort lîschen

 	CLD ; Direktionflag fÅr Richtung vorwÑrts stosb

	test ESI,255
	je 	CHCOPTIMIZED

; Tabelle liegt beliebig im Speicher = normale Version
	mov 	EBP,EDX
CHCYLOP:
	mov 	EDX,ECX
CHCXLOP:
	mov 	AL,[EDI]  ; QuellPixel
	mov 	AL,[ESI+EAX]  ; IndexWert aus Tabelle
	stosb  		 ; schreiben
	dec 	EDX
	jg 	CHCXLOP
	add 	EDI,EBX  ; Modulo addieren
	dec 	EBP
	jg 	CHCYLOP

	ret

; Tabelle liegt an 256 Byte Grenze = optimierte Version
CHCOPTIMIZED:

	mov 	EAX,ESI

	mov 	EBP,EDX
CHCYLOP_O:

	mov	EDX,ECX
	shl	EDX,2
	add 	EDX,CHCOLJMPTABLE
	jmp 	[EDX]
CHCOLLABELNUM = (MAXSCREENWIDTH_PCLIB)-1
	repeat MAXSCREENWIDTH_PCLIB  ; Macro generiert 640/2 eintrÑge mit Label
	CHCOLLABEL CATSTR <CHCOLLAB>,%CHCOLLABELNUM
	mov 	AL,[EDI]  ; QuellPixel
	mov 	AL,[EAX]  ; IndexWert aus Tabelle
	stosb  		 ; schreiben
%CHCOLLABEL:
	CHCOLLABELNUM = CHCOLLABELNUM - 1
	ENDM

	add 	EDI,EBX  ; Modulo addieren
	dec 	EBP
	jg 	CHCYLOP_O

	ret
OPM_ASS_ChangeCol_ ENDP

 					ALIGN 4
; Sprungtabelle fÅr Langworte normales TexturePolygon
CHCOLJMPTABLE:
	CHCOLLABELNUM = 0
	REPEAT MAXSCREENWIDTH_PCLIB
	CHCOLLABEL	CATSTR <CHCOLLAB>,%CHCOLLABELNUM
	DD CHCOLLABEL
	CHCOLLABELNUM = CHCOLLABELNUM + 1
	ENDM

;ZOOMBOB
;******************************************************************************
;* #FUNCTION HEADER BEGIN#
;* NAME      : OPM_ASS_ZOOM
;* FUNCTION  : Stellt OPM mit wahlweiser Breite und Hîhe dar (interne Funktion)
;*					Farbe 0 wird durchsichtig dargestellt
;*
;* INPUTS    : OPM(EDI)= Zeiger auf OPM
;*					Xpos(EAX) = X Position Bildschirm
;*					Ypos(EBX) = Y Position Bildschirm
;*					sizex(ECX) = neue Grîsse in X
;*					sizey(EDX) = neue Grîsse in Y
;* INPUTS    : sourceptr = Zeiger auf QUELLOPM
;*					destptr = Zeiger auf Zielopm
;*					sourcenextypos = Breite QuellHauptopm
;*					sourcewidth = Breite QuellBereich
;*					sourceheight = Hîhe QuellBereich
;*					destnextypos = Breite ZielHauptopm
;*					destwidth = neue Breite ZielBereich
;*					destheight = neue Hîhe ZielBereich
;*					destx = xpos ZielBereich
;*					desty = ypos ZielBereich
;* zusÑtzlich mÅssen folgende Globale Variablen initialisiert sein !
;*					destcx0 = Clipx0 Zielbereich
;*					destcy0 = Clipy0 Zielbereich
;*					destcx1 = Clipx1 Zielbereich
;*					destcy1 = Clipy1 Zielbereich
;* RESULT    :
;*
;* FILE      : SCREEN.ASM
;* AUTHOR    : VIPER
;* FIRST     : 30.08.94 13:35:58
;* LAST      : 18.01.95 15:40:55
;* BUGS      :
;* NOTES     : Das QuellOPM darf kein virtuelles OPM sein !!!
;* SEE ALSO  :
;* VERSION   : 0.1
;* #FUNCTION HEADER END#

OPM_ASS_Zoom_ PROC C USES EBP sourceptr:DWORD,destptr:DWORD,sourcenextypos:DWORD,sourcewidth:DWORD,sourceheight:DWORD,destnextypos:DWORD,destwidth:DWORD,destheight:DWORD,destxpos:DWORD,destypos:DWORD
; ZielBob zentrieren
	movme	ZOOM_DWIDTH,DESTWIDTH
	movme	ZOOM_DHEIGHT,DESTHEIGHT

;	Breite / Hîhe des OPMS
	mov 	EAX,SOURCEWIDTH  ; Breite
	sal	EAX,16
	mov	ZOOM_SWIDTH,EAX
	mov	ZOOM_SBAKWIDTH,EAX

	mov 	EAX,SOURCEHEIGHT  ; Hîhe des OPM
	sal	EAX,16
	mov	ZOOM_SHEIGHT,EAX
	mov	ZOOM_SBAKHEIGHT,EAX

; Clipping
	movme	ZOOM_SXOFFSET,ZOOM_SBAKWIDTH ; Offset auf QuellBitmap
	mov	ZOOM_SYOFFSET,0

; links
	mov	EAX,DESTXPOS
	sub 	EAX,_ZOOM_DESTCLIPX0
	jns	CLIPZOMLEFT_BLOCK
	neg	EAX
	sub	ZOOM_DWIDTH,EAX ; Ziel Breite - X offset
	test	ZOOM_DWIDTH,-1 ; Breite <=0 dann Object ausserhalb des Screens
	jle	WRONGZOOMSIZE_BLOCK
	imul	ZOOM_SBAKWIDTH ; * Breite Quell
	idiv	DESTWIDTH ; / Breite Ziel
	sub	ZOOM_SWIDTH,EAX ; Quell Breite - skalierter Offset
	rol	EAX,16
	mov	ZOOM_SXOFFSET,EAX ; X Offset der auf QuellBitmap aufaddiert wird
	movme	DESTXPOS,_ZOOM_DESTCLIPX0
CLIPZOMLEFT_BLOCK:

; rechts
	mov	EAX,DESTXPOS
	add	EAX,ZOOM_DWIDTH
	dec	EAX
	sub 	EAX,_ZOOM_DESTCLIPX1
	jle	CLIPZOMRIGHT_BLOCK
	sub	ZOOM_DWIDTH,EAX ; Ziel Breite - X offset
	test	ZOOM_DWIDTH,-1 ; Breite <=0 dann Object ausserhalb des Screens
	jle	WRONGZOOMSIZE_BLOCK
	imul	ZOOM_SBAKWIDTH ; * Breite Quell
	idiv	DESTWIDTH ; / Breite Ziel
	sub	ZOOM_SWIDTH,EAX ; Quell Breite - skalierter Offset
CLIPZOMRIGHT_BLOCK:

; oben
	mov	EAX,DESTYPOS
	sub	EAX,_ZOOM_DESTCLIPY0
	jns	CLIPZOMTOP_BLOCK
	neg	EAX
	sub	ZOOM_DHEIGHT,EAX ; Ziel Breite - X offset
	test	ZOOM_DHEIGHT,-1 ; Breite <=0 dann Object ausserhalb des Screens
	jle	WRONGZOOMSIZE_BLOCK
	imul	ZOOM_SBAKHEIGHT ; * Breite Quell
	idiv	DESTHEIGHT ; / Breite Ziel
	sub	ZOOM_SHEIGHT,EAX ; Quell Breite - skalierter Offset
	rol	EAX,16 ; Hi mit LoWort vertauschen
	mov	ZOOM_SYOFFSET,EAX ; X Offset der auf QuellBitmap aufaddiert wird
	movme	DESTYPOS,_ZOOM_DESTCLIPY0
CLIPZOMTOP_BLOCK:

; unten
	mov	EAX,DESTYPOS
	add	EAX,ZOOM_DHEIGHT
	dec	EAX
	sub	EAX,_ZOOM_DESTCLIPY1
	jle	CLIPZOMBOTTOM_BLOCK
	sub	ZOOM_DHEIGHT,EAX ; Ziel Breite - X offset
	test	ZOOM_DHEIGHT,-1 ; Breite <=0 dann Object ausserhalb des Screens
	jle	WRONGZOOMSIZE_BLOCK
	imul	ZOOM_SBAKHEIGHT ; * Breite Quell
	idiv	DESTHEIGHT ; / Breite Ziel
	sub	ZOOM_SHEIGHT,EAX ; Quell Breite - skalierter Offset
CLIPZOMBOTTOM_BLOCK:

; an rechte Grenze setzen
	mov 	EAX,SOURCEPTR  ; Bitmap des OPMs
	add	EAX,SOURCEWIDTH
	mov	ZOOM_SBITMAP,EAX ; an rechte Grenze setzen
	mov	EDI,DESTPTR ; AusgabeBildschirm

	mov	EAX,DESTYPOS ; Position am Bildschirm
	imul 	EAX,DESTNEXTYPOS
	add	EAX,DESTXPOS
	add	EDI,EAX

	mov	EAX,ZOOM_SWIDTH
	mov	EBX,ZOOM_DWIDTH ; neue Breite
	cdq
	idiv EBX
	rol 	EAX,16  ; Hi mit LoWort vertauschen
	mov	ZOOM_MX,EAX ; Steigung fÅr X

	mov	EAX,ZOOM_SHEIGHT
 	mov	EBX,ZOOM_DHEIGHT ; neue Hîhe
	cdq
	idiv EBX
	rol 	EAX,16  ; Hi mit LoWort vertauschen
	mov	ZOOM_MY,EAX ; Steigung fÅr Y

	movme	SOURCEWIDTHII,SOURCENEXTYPOS
	mov	EAX,DESTNEXTYPOS
	sub	EAX,ZOOM_DWIDTH
	mov	DESTWIDTHII,EAX

	push	EBP

	CLD ; Richtung stosb vorwÑrts

	cmp	zoommode,ZOOMMODE_SILHOUETTE
	je		shilouettenmode

;**************************************
; normaler Zoommode
;**************************************

; gezoomtes OPM darstellen
	mov	EBX,ZOOM_MX
	mov	EBP,ZOOM_SYOFFSET ; Clip Y Offset
	movme ZOOM_LOPVAR,ZOOM_DHEIGHT
YZOMDRAW_NORMAL:
	mov	ESI,ZOOM_SBITMAP ; StartAddresse Screen
	movzx	EDX,BP ; LoWort = Ganzzahl
	imul	EDX,SOURCEWIDTHII ; mit PixelBreite multiplizieren
	add	ESI,EDX ; nÑchste Zeile Quellopm

	mov	EDX,ZOOM_SXOFFSET ; Clip X Offset
	mov	ECX,ZOOM_DWIDTH
ZOOMLOOP_NORMAL:

 	add	EDX,EBX ; X addieren
	adc	EDX,0
	movsx	EAX,DX ; LoWort = Ganzzahl

	mov	al,[ESI+EAX] ; Pixel lesem
	or		al,al
	je 	@F
	stosb
	dec	ECX
	jg		ZOOMLOOP_NORMAL
	jmp	ENDZOOMLOP_NORMAL
@@:
	inc	edi
	dec	ECX
	jg		ZOOMLOOP_NORMAL
ENDZOOMLOP_NORMAL:

	add	EBP,ZOOM_MY ; Y addieren
	adc	EBP,0
	add	EDI,DESTWIDTHII ; Modulo nÑchste Zeile Bildschirm
	dec 	ZOOM_LOPVAR
	jg 	YZOMDRAW_NORMAL

	pop	EBP

	ret
OPM_ASS_Zoom_ ENDP















; ZielBob zentrieren
	movme	ZOOM_DWIDTH,DESTWIDTH
	movme	ZOOM_DHEIGHT,DESTHEIGHT

;	Breite / Hîhe des OPMS

	mov 	EAX,SOURCEWIDTH  ; Breite
	sal	EAX,16
	mov	ZOOM_SWIDTH,EAX
	mov	ZOOM_SBAKWIDTH,EAX

	mov 	EAX,SOURCEHEIGHT  ; Hîhe des OPM
	sal	EAX,16
	mov	ZOOM_SHEIGHT,EAX
	mov	ZOOM_SBAKHEIGHT,EAX

; Clipping

	movme	ZOOM_SXOFFSET,ZOOM_SBAKWIDTH ; Offset auf QuellBitmap
	mov	ZOOM_SYOFFSET,0

; links
	mov	EAX,DESTXPOS
	sub 	EAX,_ZOOM_DESTCLIPX0
	jns	CLIPZOMLEFT
	neg	EAX
	sub	ZOOM_DWIDTH,EAX ; Ziel Breite - X offset
	test	ZOOM_DWIDTH,-1 ; Breite <=0 dann Object ausserhalb des Screens
	jle	WRONGZOOMSIZE
	imul	ZOOM_SBAKWIDTH ; * Breite Quell
	idiv	DESTWIDTH ; / Breite Ziel
	sub	ZOOM_SWIDTH,EAX ; Quell Breite - skalierter Offset
	movme	DESTXPOS,_ZOOM_DESTCLIPX0
CLIPZOMLEFT:

; rechts
	mov	EAX,DESTXPOS
	add	EAX,ZOOM_DWIDTH
	dec	EAX
	sub 	EAX,_ZOOM_DESTCLIPX1
	jle	CLIPZOMRIGHT
	sub	ZOOM_DWIDTH,EAX ; Ziel Breite - X offset
	test	ZOOM_DWIDTH,-1 ; Breite <=0 dann Object ausserhalb des Screens
	jle	WRONGZOOMSIZE
	imul	ZOOM_SBAKWIDTH ; * Breite Quell
	idiv	DESTWIDTH ; / Breite Ziel
	sub	ZOOM_SWIDTH,EAX ; Quell Breite - skalierter Offset
	neg	EAX
	rol	EAX,16 ; Hi mit LoWort vertauschen
	mov	ZOOM_SXOFFSET,EAX ; X Offset der auf QuellBitmap aufaddiert wird
CLIPZOMRIGHT:

; oben
	mov	EAX,DESTYPOS
	sub	EAX,_ZOOM_DESTCLIPY0
	jns	CLIPZOMTOP
	neg	EAX
	sub	ZOOM_DHEIGHT,EAX ; Ziel Breite - X offset
	test	ZOOM_DHEIGHT,-1 ; Breite <=0 dann Object ausserhalb des Screens
	jle	WRONGZOOMSIZE
	imul	ZOOM_SBAKHEIGHT ; * Breite Quell
	idiv	DESTHEIGHT ; / Breite Ziel
	sub	ZOOM_SHEIGHT,EAX ; Quell Breite - skalierter Offset
	rol	EAX,16 ; Hi mit LoWort vertauschen
	mov	ZOOM_SYOFFSET,EAX ; X Offset der auf QuellBitmap aufaddiert wird
	movme	DESTYPOS,_ZOOM_DESTCLIPY0
CLIPZOMTOP:

; unten
	mov	EAX,DESTYPOS
	add	EAX,ZOOM_DHEIGHT
	dec	EAX
	sub	EAX,_ZOOM_DESTCLIPY1
	jle	CLIPZOMBOTTOM
	sub	ZOOM_DHEIGHT,EAX ; Ziel Breite - X offset
	test	ZOOM_DHEIGHT,-1 ; Breite <=0 dann Object ausserhalb des Screens
	jle	WRONGZOOMSIZE
	imul	ZOOM_SBAKHEIGHT ; * Breite Quell
	idiv	DESTHEIGHT ; / Breite Ziel
	sub	ZOOM_SHEIGHT,EAX ; Quell Breite - skalierter Offset
CLIPZOMBOTTOM:

; an rechte Grenze setzen
	mov 	EAX,SOURCEPTR  ; Bitmap des OPMs
	add	EAX,SOURCEWIDTH
	mov	ZOOM_SBITMAP,EAX ; an rechte Grenze setzen
	mov	EDI,DESTPTR ; AusgabeBildschirm

	mov	EAX,DESTYPOS ; Position am Bildschirm
	imul 	EAX,DESTNEXTYPOS
	add	EAX,DESTXPOS
	add	EDI,EAX

	mov	EAX,ZOOM_SWIDTH
	mov	EBX,ZOOM_DWIDTH ; neue Breite
	neg	EBX
	cdq
	idiv EBX
	rol 	EAX,16  ; Hi mit LoWort vertauschen
	mov	ZOOM_MX,EAX ; Steigung fÅr X

	mov	EAX,ZOOM_SHEIGHT
 	mov	EBX,ZOOM_DHEIGHT ; neue Hîhe
	cdq
	idiv EBX
	rol 	EAX,16  ; Hi mit LoWort vertauschen
	mov	ZOOM_MY,EAX ; Steigung fÅr Y

	movme	SOURCEWIDTHII,SOURCENEXTYPOS
	movme	DESTWIDTHII,DESTNEXTYPOS

	push	EBP

; gezoomtes OPM darstellen
	mov	EBX,ZOOM_MX
	mov	EBP,ZOOM_SYOFFSET ; Clip Y Offset
	movme ZOOM_LOPVAR,ZOOM_DHEIGHT
YZOMDRAW:
	mov	ESI,ZOOM_SBITMAP ; StartAddresse Screen
	movzx	EDX,BP ; LoWort = Ganzzahl
	imul	EDX,SOURCEWIDTHII ; mit PixelBreite multiplizieren
	add	ESI,EDX ; nÑchste Zeile Quellopm

	mov	EAX,ZOOM_SXOFFSET ; Clip X Offset
	mov	EDX,ZOOM_DWIDTH

	shl	EDX,2
	add 	EDX,ZOOMBOBJMPTABLE
	jmp 	[EDX]
TXTOFFSET = MAXSCREENWIDTH_PCLIB-1
TXTLABELNUM = MAXSCREENWIDTH_PCLIB-1
	repeat MAXSCREENWIDTH_PCLIB  ; Macro generiert 640/2 eintrÑge mit Label
	txtlabel CATSTR <ZOMBOBLAB>,%TXTLABELNUM

 	add	EAX,EBX ; X addieren
	adc	EAX,0
	movsx	EDX,AX ; LoWort = Ganzzahl

	mov	dl,[ESI+EDX] ; Pixel lesem
	or		dl,dl
	je 	@F
	mov	TXTOFFSET[EDI],dl
@@:

%TXTLABEL:
	txtoffset = txtoffset - 1
	txtlabelnum = txtlabelnum - 1
	ENDM

	add	EBP,ZOOM_MY ; Y addieren
	adc	EBP,0
	add	EDI,DESTWIDTHII ; Modulo nÑchste Zeile Bildschirm
	dec 	ZOOM_LOPVAR
	jg 	YZOMDRAW

	pop	EBP

WRONGZOOMSIZE:

	ret
OPM_ASS_Zoom_ ENDP

; Sprungtabelle fÅr Langworte geshadedtes TexturePolygon
ZOOMBOBJMPTABLE:
	txtlabelnum = 0
	REPEAT MAXSCREENWIDTH_PCLIB
	txtlabel	CATSTR <ZOMBOBLAB>,%txtlabelnum
	DD txtlabel
	txtlabelnum = txtlabelnum + 1
	ENDM

; ******************************************************************************
; * #FUNCTION HEADER BEGIN#
; * NAME      : OPM_ASS_Blit(srcdata,dstdata,srcmodulo,dstmodulo,width,height);
; * FUNCTION  : Kopiert Daten Zeilenweise mit Modulo
; *							srcdata(ESI) = Quelldatenbereich
; *							dstdata(EDI) = Zieldatenbereich
; *							srcmodulo(eax) = Modulo Quelle
; *							dstmodulo(ecx) = Modulo Ziel
; * 							width(ebx) = Breite in Pixel
; * 							height(edx) = Hoehe in Pixel
; * FILE      : DSA_ASS.ASM
; * AUTHOR    : viper
; * FIRST     : 25.05.94 14:00
; * LAST      :10.11.94 16:34:56
; * INPUTS    :
; * RESULT    : None.
; * BUGS      :
; * NOTES     :
; * SEE ALSO  :
; * VERSION   : 1.0
; * #FUNCTION HEADER END#

OPM_ASS_Blit_ PROC C USES EBP
	push ES

	mov 	EBP,ECX

	mov 	CX,DS
	mov 	ES,CX

	jmp 	JMPCOPYMHEIGHT
COPYMHEIGHT:
	mov 	ECX,EBX
	shr 	ECX,2
	rep 	MOVSD  ; restliche Zeile mit Langworten kopieren
	mov 	CL,BL  ; zu kopierende Breite fÅr opm
	and 	CL,3
	rep 	MOVSB  ; Restbytes kopieren
	add 	ESI,EAX  ; QuellModulo
	add 	EDI,EBP  ; ZielModulo
JMPCOPYMHEIGHT:
	dec 	EDX
	jns 	COPYMHEIGHT

	pop 	ES

	ret
OPM_ASS_Blit_ ENDP

; ******************************************************************************
; * #FUNCTION HEADER BEGIN#
; * NAME      : OPM_ASS_Blit_Trans
; * FUNCTION  : Kopiert Daten Zeilenweise mit Modulo und einer Transparenzfarbe
; *							srcdata(ESI) = Quelldatenbereich
; *							dstdata(EDI) = Zieldatenbereich
; *							srcmodulo(edx) = Modulo Quelle
; *							dstmodulo(ecx) = Modulo Ziel
; * 						width(ebx) = Breite in Pixel
; * 						height(eax) = Hoehe in Pixel
; *						transcol = Transcol
; * FILE      : DSA_ASS.ASM
; * AUTHOR    : viper
; * FIRST     : 25.05.94 14:00
; * LAST      :10.11.94 17:39:44
; * INPUTS    :
; * RESULT    : None.
; * BUGS      :
; * NOTES     :
; * SEE ALSO  :
; * VERSION   : 1.0
; * #FUNCTION HEADER END#

OPM_ASS_Blit_Trans_ PROC C USES EBP TRANSCOL:DWORD
	push ES

	mov	YLOP,EAX ; Schleifenvariable
	mov 	EAX,TRANSCOL  ; transparente Farbe
	shl	EAX,8 ; ins Hibyte

	mov 	EBP,ECX  ; dstmodulo

	mov 	CX,DS
	mov 	ES,CX ; nach es fÅr stosb

	CLD ; Direktionflag fÅr Richtung vorwÑrts stosb

	jmp 	JMPCOPYMHEIGHT_TRANS
COPYMHEIGHT_TRANS:

	mov 	ECX,EBX
HORLOP_TRANS:
	lodsb  		 ; Byte lesen
	cmp 	AL,AH
	je 	COL_TRANS  ; Farbe gleich Åberspringen
	stosb  		 ; Byte schreiben
	dec 	ECX
	jg 	HORLOP_TRANS
	jmp 	ENDCOL_TRANS
COL_TRANS:
	inc 	EDI
	dec 	ECX
	jg 	HORLOP_TRANS
ENDCOL_TRANS:

	add 	ESI,EDX  ; QuellModulo
	add 	EDI,EBP  ; ZielModulo
JMPCOPYMHEIGHT_TRANS:
	dec 	YLOP
	jns 	COPYMHEIGHT_TRANS

	pop 	ES
	ret

OPM_ASS_Blit_Trans_ ENDP

OPM  	ENDS 				;

OPM_DATA	SEGMENT PARA USE32 'DATA'	;

; Lokale Variablen ZoomBobFunktion
ZOOM_DWIDTH DD ?
ZOOM_DHEIGHT DD ?
ZOOM_SBITMAP DD ?
ZOOM_SWIDTH DD ?
ZOOM_SHEIGHT DD ?
ZOOM_SBAKWIDTH DD ?
ZOOM_SBAKHEIGHT DD ?
ZOOM_SXOFFSET DD ?
ZOOM_SYOFFSET DD ?
ZOOM_MX DD ?
ZOOM_MY DD ?
ZOOM_DWIDTHMODULO DD ?
SOURCEWIDTHII DD ?
DESTWIDTHII DD ?
_ZOOM_DESTCLIPX0 DD ?
_ZOOM_DESTCLIPY0 DD ?
_ZOOM_DESTCLIPX1 DD ?
_ZOOM_DESTCLIPY1 DD ?
ZOOM_LOPVAR DD ?
YLOP DD ? ; Schleifenvariable

OPM_DATA	ENDS

END


