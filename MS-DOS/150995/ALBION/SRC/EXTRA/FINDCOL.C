/************
 * NAME     : FINDCOL.C
 * AUTHOR   : Jurie Horneman, BlueByte & Dave Thielen
 * START    : 11-11-1994
 * PROJECT  : Find closest colour function
 * NOTES    :
 * SEE ALSO : FINDCOL.H
 ************/

/* includes */

#include <string.h>
#include <stdlib.h>

#include <BBDEF.H>
//#include <BBDSA.H>

#include <SORT.H>

#include <FINDCOL.H>

/* defines */

/* Number of colours in a palette */
#define SCREEN_PALETTE_ENTRIES	(256)

/* structure definitions */

/* One palette entry */
struct BBCOLOR
{
	UNBYTE red;
	UNBYTE green;
	UNBYTE blue;
	UNBYTE alpha;
};

/* Palette structure */
struct BBPALETTE
{
	UNSHORT entries;
	UNSHORT version;
	struct BBCOLOR	color[SCREEN_PALETTE_ENTRIES];
};

/* Colour sort table entry */
struct Sort_colour {
	UNBYTE R, G, B;
	UNBYTE Index;
};

/* global variables */

static UNBYTE Protected_colours[SCREEN_PALETTE_ENTRIES];
static struct Sort_colour Sorted_palette[SCREEN_PALETTE_ENTRIES];
static UNSHORT Nr_find_colours;

/* prototypes */

static void Swap_colours(UNLONG A, UNLONG B, UNBYTE *Data);
static BOOLEAN Compare_colours(UNLONG A, UNLONG B, UNBYTE *Data);

/*
 ******************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Prepare_colour_find
 * FUNCTION  : Prepare a palette for colour-finding.
 * FILE      : FINDCOL.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 11.11.94 14:41
 * LAST      : 11.11.94 14:41
 * INPUTS    : struct BBPALETTE *Pal - Pointer to colour palette.
 *             UNSHORT Start - Number of first colour (0...255).
 *             UNSHORT Number - Number of colours to check.
 * RESULT    : None.
 * BUGS      : No known.
 * NOTES     : - This function must be called every time unprotected colours
 *              are changed, e.g. when a new palette has been loaded.
 *             - Colours must be protected BEFORE calling this function.
 * SEE ALSO  :
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

void
Prepare_colour_find(struct BBPALETTE *Pal, UNSHORT Start, UNSHORT Number)
{
	UNSHORT i, j;

	/* Put colours into array */
	j = 0;
	for (i=Start;i<Start+Number;i++)
	{
		/* Is this colour protected ? */
		if (!Protected_colours[i])
		{
			/* No -> Put colour into array */
			Sorted_palette[j].R = Pal->color[i].red;
			Sorted_palette[j].G = Pal->color[i].green;
			Sorted_palette[j].B = Pal->color[i].blue;

			/* Put colour number into array */
			Sorted_palette[j].Index = i;

			/* Next colour */
			j++;
		}
	}

	/* Store total number of colours */
	Nr_find_colours = j;

	/* Sort palette */
	Shellsort(Swap_colours, Compare_colours, Nr_find_colours,
	 (UNBYTE *) &(Sorted_palette[0]));
}

/*
 ******************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Find_closest_colour
 * FUNCTION  : Search a palette for the colour which best matches a certain
 *              target colour.
 * FILE      : FINDCOL.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 07.09.94 12:03
 * LAST      : 11.11.94 14:39
 * INPUTS    : UNSHORT Red - Target red value.
 *             UNSHORT Green - Target green value.
 *             UNSHORT Blue - Target blue value.
 * RESULT    : UNBYTE : Colour number (0...255).
 * BUGS      : No known.
 * NOTES     : - Only colours processed by Prepare_colour_find() can be
 *              found.
 *             - This function uses a local copy of the palette generated by
 *              Prepare_colour_find().
 *             - This function accesses no other functions and does not
 *              call any memory manager functions.
 * SEE ALSO  :
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

UNBYTE
Find_closest_colour(UNSHORT Red, UNSHORT Green, UNSHORT Blue)
{
	UNLONG Diff;
	UNLONG Right_diff;
	UNLONG Left_diff;
	UNLONG Green_diff;
	SISHORT Middle;
	SISHORT Left;
	SISHORT Right;
	SISHORT dR, dG, dB;

	/* Make a binary search to find the closest matching green */
	Left = 0;
	Right = Nr_find_colours - 1;

	for (;;)
	{
		/* Get the middle between left and right boundaries */
		Middle = (Left + Right) / 2;

		/* Is the desired value to the left or to the right ? */
		if (Green < Sorted_palette[Middle].G)
		{
			/* To the left -> Can we narrow the searching range ? */
			if (Middle - 1 < Left)
				/* No -> break */
				break;

			/* Yes -> Change the right boundary */
			Right = Middle - 1;
		}
		else
		{
			/* To the right -> Can we narrow the searching range ? */
			if (Middle + 1 > Right)
				/* No -> break */
				break;

			/* Yes -> Change the left boundary */
			Left = Middle + 1;
		}

		/* Is this exactly the desired green value ? */
		if (Green == Sorted_palette[Middle].G)
		{
			/* Yes -> break */
			Right = Middle;
			break;
		}
	}

	/* Should we use the left or the right boundary ? */
	Left_diff = abs(Sorted_palette[Left].G - Green);
	Right_diff = abs(Sorted_palette[Right].G - Green);

	if (Left_diff < Right_diff)
		Middle = Left;
	else
		Middle = Right;

	/* Find the current difference */
	dR = Sorted_palette[Middle].R - Red;
	dG = Sorted_palette[Middle].G - Green;
	dB = Sorted_palette[Middle].B - Blue;

	Diff = (dR * dR) + (dG * dG) + (dB * dB);

	/* Is this already an exact match ? */
	if (Diff)
	{
		/* No -> Search outwards */
		Left = Middle;
		Right = Middle;

		for (;;)
		{
			/* Can we still search to the left ? */
			if (Left > 0)
			{
				/* Yes -> Move to the left */
				Left--;

				/* Calculate green difference */
				dG = Sorted_palette[Left].G - Green;
				Green_diff = (dG * dG);

				/* Is the green difference already above the total difference ? */
				if (Green_diff > Diff)
				{
					/* Yes -> Stop searching to the left */
					Left = -1;
				}
				else
				{
					/* No -> Calculate the total difference */
					dR = Sorted_palette[Left].R - Red;
					dB = Sorted_palette[Left].B - Blue;
					Left_diff = Green_diff + (dR * dR) + (dB * dB);

					/* Lower than the current record ? */
					if (Left_diff < Diff)
					{
						/* Yes -> This is a closer match */
						Middle = Left;

						/* Is it an exact match ? */
						if (!Left_diff)
							/* Yes -> break */
							break;

						/* No */
						Diff = Left_diff;
					}
				}
			}

			/* Are we still searching to the right ? */
			if (Right < Nr_find_colours-1)
			{
				/* Yes -> Move to the right */
				Right++;

				/* Calculate green difference */
				dG = Sorted_palette[Right].G - Green;
				Green_diff = (dG * dG);

				/* Is the green difference already above the total difference ? */
				if (Green_diff > Diff)
				{
					/* Yes -> Stop searching to the right */
					Right = Nr_find_colours;
				}
				else
				{
					/* No -> Calculate the total difference */
					dR = Sorted_palette[Right].R - Red;
					dB = Sorted_palette[Right].B - Blue;
					Right_diff = Green_diff + (dR * dR) + (dB * dB);

					/* Lower than the current record ? */
					if (Right_diff < Diff)
					{
						/* Yes -> This is a closer match */
						Middle = Right;

						/* Is it an exact match ? */
						if (!Right_diff)
							/* Yes -> break */
							break;

						/* No */
						Diff = Right_diff;
					}
				}
			}

			/* Have we stopped searching in both directions ? */
			if ((Left <= 0) && (Right >= Nr_find_colours-1))
				/* Yes -> break */
				break;
		}
	}

	/* Return the palette index of the found colour */
	return Sorted_palette[Middle].Index;
}

/*
 ******************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Swap_colours
 * FUNCTION  : Swap two colours (for sorting).
 * FILE      : FINDCOL.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 11.11.94 14:49
 * LAST      : 11.11.94 14:49
 *	INPUTS    : UNLONG A - Index of first element (0...).
 *	            UNLONG B - Index of second element (0...).
 *	            UNBYTE *Data - Pointer to data passed by Sort() caller.
 * RESULT    : None.
 * BUGS      : No known.
 * SEE ALSO  :
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

void
Swap_colours(UNLONG A, UNLONG B, UNBYTE *Data)
{
	struct Sort_colour *SCA, *SCB, T;

	SCA = ((struct Sort_colour *) Data) + A;
	SCB = ((struct Sort_colour *) Data) + B;

	memcpy (&T, SCA, sizeof(struct Sort_colour));
	memcpy (SCA, SCB, sizeof(struct Sort_colour));
	memcpy (SCB, &T, sizeof(struct Sort_colour));
}

/*
 ******************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Compare_colours
 * FUNCTION  : Compare two colours (for sorting).
 * FILE      : FINDCOL.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 11.11.94 14:49
 * LAST      : 11.11.94 14:49
 *	INPUTS    : UNLONG A - Index of first element (0...).
 *	            UNLONG B - Index of second element (0...).
 *	            UNBYTE *Data - Pointer to data passed by Sort() caller.
 *	RESULT    : TRUE or FALSE.
 * BUGS      : No known.
 * SEE ALSO  :
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

BOOLEAN
Compare_colours(UNLONG A, UNLONG B, UNBYTE *Data)
{
	struct Sort_colour *SCA, *SCB;

	SCA = ((struct Sort_colour *) Data) + A;
	SCB = ((struct Sort_colour *) Data) + B;

	return(SCA->G > SCB->G);
}

/*
 ******************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Clear_protected_colours
 * FUNCTION  : Remove all colours from the protected colour list.
 * FILE      : FINDCOL.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 11.11.94 15:07
 * LAST      : 11.11.94 15:07
 * INPUTS    : None.
 * RESULT    : None.
 * BUGS      : No known.
 * SEE ALSO  :
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

void
Clear_protected_colours(void)
{
	UNSHORT i;

	/* Clear all entries */
	for (i=0;i<SCREEN_PALETTE_ENTRIES;i++)
	{
		Protected_colours[i] = 0;
	}
}

/*
 ******************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Add_protected_colours
 * FUNCTION  : Add colours to protected colour list.
 * FILE      : FINDCOL.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 03.11.94 15:00
 * LAST      : 03.11.94 15:00
 * INPUTS    : UNSHORT Start - Number of first colour (0...255).
 *             UNSHORT Size - Number of colours to add.
 * RESULT    : None.
 * BUGS      : No known.
 * SEE ALSO  :
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

void
Add_protected_colours(UNSHORT Start, UNSHORT Size)
{
	UNSHORT i;

	/* Increase all entries in the given range */
	for (i=Start;i<Start+Size;i++)
	{
		if (Protected_colours[i] != 255)
			Protected_colours[i]++;
	}
}

/*
 ******************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Remove_protected_colours
 * FUNCTION  : Remove colours from protected colour list.
 * FILE      : FINDCOL.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 03.11.94 15:02
 * LAST      : 03.11.94 15:02
 * INPUTS    : UNSHORT Start - Number of first colour (0...255).
 *             UNSHORT Size - Number of colours to remove.
 * RESULT    : None.
 * BUGS      : No known.
 * SEE ALSO  :
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

void
Remove_protected_colours(UNSHORT Start, UNSHORT Size)
{
	UNSHORT i;

	/* Decrease all entries in the given range */
	for (i=Start;i<Start+Size;i++)
	{
		if (Protected_colours[i])
			Protected_colours[i]--;
	}
}

#if FALSE
/*
 ******************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Find_closest_colour
 * FUNCTION  : Search a palette for the colour which best matches a certain
 *              target colour.
 * FILE      : FINDCOL.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 24.06.95 14:31
 * LAST      : 24.06.95 14:31
 * INPUTS    : UNSHORT Red - Target red value.
 *             UNSHORT Green - Target green value.
 *             UNSHORT Blue - Target blue value.
 * RESULT    : UNBYTE : Colour number (0...255).
 * BUGS      : No known.
 * SEE ALSO  :
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

UNBYTE
Find_closest_colour(UNSHORT Red, UNSHORT Green, UNSHORT Blue)
{
	UNLONG Max1 = 0xFFFFFFFF;
	UNLONG Max2 = 0xFFFFFFFF;
	UNLONG d;
	UNSHORT i;
	SISHORT R, G, B;
	UNBYTE Target = 0;

	extern struct BBPALETTE Palette;

	UNSHORT Start = 0;
	UNSHORT Number = 256;
	struct BBPALETTE *Pal = &Palette;

	/* Search the palette */
	for (i=Start;i<Start+Number;i++)
	{
		/* If the colour is not protected */
		if (!Protected_colours[i])
		{
			/* Calculate the differences between the current and the target colour */
			R = abs ((UNSHORT) Pal->color[i].red - Red);
			if (R > Max1)
				continue;
			G = abs ((UNSHORT) Pal->color[i].green - Green);
			if (G > Max1)
				continue;
			B = abs ((UNSHORT) Pal->color[i].blue - Blue);
			if (B > Max1)
				continue;

			/* Calculate the rough distance between the current and the target colour */
			d = R + G + B;

			/* Is this distance smaller than the current record ? */
			if (d < Max1)
			{
				/* Yes -> Is it an EXACT match ? */
				if (!d)
				{
					/* Yes -> Exit */
					Target = i;
					break;
				}

				/* No -> Calculate the exact distance */
				d = (R * R) + (G * G) + (B * B);

				/* Is this distance smaller than the current record ? */
				if (d < Max2)
				{
					/* Yes -> This is a closer match */
					Max1 = R + G + B;
					Max2 = d;
					Target = i;
				}
			}
		}
	}
	return Target;
}
#endif

