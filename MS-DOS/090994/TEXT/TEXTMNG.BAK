/************
 * NAME     : TEXTMNG.C
 * AUTHOR   : Jurie Horneman, BlueByte
 * START    : 24-8-1994
 * PROJECT  : Text functions
 * NOTES    : - These functions assume that NULL and FALSE are 0.
 * SEE ALSO :
 ************/

/* includes */

#include <BBDEF.H>
#include <BBMEM.H>
#include <BBOPM.H>
#include <BBDSA.H>

#include <TEXT.H>
#include "TEXTVAR.H"

#include <FONT.H>

extern struct SCREENPORT Screen;

/* global variables */

SILONG Current_text_Y;

/*
 *****************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Display_text
 * FUNCTION  : Display a single text.
 * FILE      : TEXTMNG.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 24.08.94 17:20
 * LAST      : 24.08.94 17:20
 * INPUTS    : struct OPM *OPM - Pointer to target OPM.
 *             UNCHAR *Text - Pointer to text string.
 * RESULT    : None.
 * BUGS      : No known.
 * SEE ALSO  : TEXT.H
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

void
Display_text(struct OPM *OPM, UNCHAR *Text)
{
	struct Processed_text Processed;

	Process_text(Text, &Processed);
	Display_processed_text(OPM, &Processed);
	//Destroy_processed_text(&Processed);
}

/*
 *****************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Display_text_list
 * FUNCTION  : Display a list of texts.
 * FILE      : TEXTMNG.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 24.08.94 17:43
 * LAST      : 24.08.94 17:43
 * INPUTS    : struct OPM *OPM - Pointer to target OPM.
 *             UNCHAR *Text_list[] - Pointer to a NULL-terminated list of
 *              text strings.
 * RESULT    : None.
 * BUGS      : No known.
 * SEE ALSO  : TEXT.H
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

void
Display_text_list(struct OPM *OPM, UNCHAR **Text_list)
{
	struct Processed_text Processed;

	Process_text_list(Text_list, &Processed);
	Display_processed_text(OPM, &Processed);
	//Destroy_processed_text(&Processed);
}

/*
 *****************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Destroy_processed_text
 * FUNCTION  : Destroy a processed text.
 * FILE      : TEXTMNG.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 25.08.94 13:32
 * LAST      : 25.08.94 13:32
 * INPUTS    : struct Processed_text *Processed - Pointer to processed text.
 * RESULT    : None.
 * BUGS      : No known.
 * SEE ALSO  : TEXT.H
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

void
Destroy_processed_text(struct Processed_text *Processed)
{
	struct TPB *TPB;
	MEM_HANDLE Handle1, Handle2;

	/* Get first handle */
	Handle1 = Processed->First_handle;
	do
	{
		/* Get TPB */
		TPB = (struct TPB *) MEM_Claim_pointer(Handle1);

		/* Get handle of next TPB */
		Handle2 = TPB->Next_handle;

		/* Destroy TPB */
		MEM_Free_pointer(Handle1);
		MEM_Free_memory(Handle1);

		/* Repeat until there is no next TPB */
		Handle1 = Handle2;
	} while (Handle1);

	/* Clear */
	Processed->First_handle = NULL;
}

/*
 *****************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Display_processed_text
 * FUNCTION  : Display a processed text.
 * FILE      : TEXTMNG.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 24.08.94 17:45
 * LAST      : 24.08.94 17:45
 * INPUTS    : struct OPM *OPM - Pointer to target OPM.
 *             struct Processed_text *Processed - Pointer to processed text
 *              data structure.
 * RESULT    : None.
 * BUGS      : No known.
 * SEE ALSO  : TEXT.H
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

void
Display_processed_text(struct OPM *OPM, struct Processed_text *Processed)
{
	MEM_HANDLE Handle;
	struct PA *PA;
	struct OPM zOPM;
	UNSHORT i;
	UNBYTE *Ptr;

	PA = PA_stack[PA_stack_index];
	OPM_CreateVirtualOPM(OPM, &zOPM, PA->Area.left, PA->Area.top,
	 PA->Area.width, PA->Area.height);

	Handle = MEM_Allocate_memory(PA->Area.width * PA->Area.height);

	Ptr = MEM_Claim_pointer(Handle);
	Get_block(&zOPM, 0, 0, PA->Area.width, PA->Area.height, Ptr);
	MEM_Free_pointer(Handle);

	//Prepare_print_area(&zOPM);

//	for (i=0;i<Processed->Text_height;i++)
//	{

	i = 0;

		Current_text_Y = i;

		Ptr = MEM_Claim_pointer(Handle);
		Put_unmasked_block(&zOPM, 0, 0, PA->Area.width, PA->Area.height, Ptr);
		MEM_Free_pointer(Handle);
		Refresh_text_window(&zOPM, 0, PA->Area.height, Processed);
		DSA_CopyOPMToScreen(&Screen, &zOPM, 0, 0, DSA_CMOPMTS_ALWAYS);
		DSA_DoubleBuffer();
	//}

	MEM_Free_memory(Handle);
}

/*
 *****************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Refresh_text_window
 * FUNCTION  : Refresh the current text window.
 * FILE      : TEXTMNG.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 24.08.94 17:47
 * LAST      : 24.08.94 17:47
 * INPUTS    : struct OPM *OPM - Pointer to target OPM.
 *             SISHORT Top - Top Y-coordinate.
 *             SISHORT Bottom - Bottom Y-coordinate.
 *             struct Processed_text *Processed - Pointer to processed text
 *              data structure.
 * RESULT    : None.
 * BUGS      : No known.
 * NOTES     : - Y-coordinate 0 corresponds with the first line of the
 *              print area. Current_text_Y will be added to this coordinate
 *              to determine the position in the text.
 * SEE ALSO  : TEXT.H
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

void
Refresh_text_window(struct OPM *OPM, SISHORT Top, SISHORT Bottom,
 struct Processed_text *Processed)
{
	struct PA *PA;
	struct BBRECT Clip, Old;
	struct TPB *Current_TPB;
	MEM_HANDLE Current_TPB_handle, Handle;
	SILONG Target_Y, Y;
	UNSHORT X;

	/* Make clip area */
	PA = PA_stack[PA_stack_index];
	Clip.left = 0;
	//PA->Area.left;
	Clip.top = Top;
	//PA->Area.top + Top;
	Clip.width = PA->Area.width;
	Clip.height = Bottom - Top + 1;

	/* Install clip area */
	memcpy(&Old, &(OPM->clip), sizeof(struct BBRECT));
	memcpy(&(OPM->clip), &Clip, sizeof(struct BBRECT));

	/* Erase the print area */
//	Erase_print_area(OPM);

	/* Determine the position of the first line in the text */
	Target_Y = Current_text_Y + Top;
	if (Target_Y < 0)
		Target_Y = 0;

	/* Find processed TPB containing the first line */
	Current_TPB_handle = Processed->First_handle;
	Current_TPB = (struct TPB *) MEM_Claim_pointer(Current_TPB_handle);
	Y = 0;
	while (TRUE)
	{
		/* Is the first line in this TPB ? */
		Y += Current_TPB->Height;
		if (Target_Y < Y)
		{
			/* Yes -> Found it */
			Y -= Current_TPB->Height;
			break;
		}

		/* No -> Was this the last TPB ? */
		Handle = Current_TPB->Next_handle;
		MEM_Free_pointer(Current_TPB_handle);

		if (!Handle)
		{
			/* Yes -> The first line is outside of the text */
			Y = -1;
			break;
		}

		/* Next TPB */
		Current_TPB_handle = Handle;
		Current_TPB = (struct TPB *) MEM_Claim_pointer(Current_TPB_handle);
	}

	/* Is the first line inside the text ? */
	if (Y != -1)
	{
		struct Line_info *Line;
		UNSHORT TPB_index;
		UNBYTE *Ptr;

		/* Yes -> find the position of the first line in this TPB */
		TPB_index = sizeof(struct TPB);
		Ptr = MEM_Get_pointer(Current_TPB_handle);

		while(TRUE)
		{
			Line = (struct Line_info *) (Ptr + TPB_index);

			/* Is this the first line ? */
			Y += Line->Skip;
			if (Target_Y < Y)
			{
				/* Yes -> Found it */
				Y -= Line->Skip;
				break;
			}

			/* No -> Next line */
			TPB_index += sizeof(struct Line_info) + Line->String_length + 1;
			if (TPB_index % 2)
				TPB_index++;
		}

		/* Print all lines */
		Target_Y += Bottom - Top + 1;
		X = 0;
		//PA->Area.left;
		Y -= Current_text_Y;
		Y += 0;
		//PA->Area.top;

		while (TRUE)
		{
			/* Print line */
			Print_processed_string(OPM, X, Y, Ptr + TPB_index);

			/* Move down */
			Y += Line->Skip;

			/* Exit if outside the area */
			if (Y >= Target_Y)
				break;

			/* Next line */
			TPB_index += sizeof(struct Line_info) + Line->String_length + 1;
			if (TPB_index % 2)
				TPB_index++;
			Line = (struct Line_info *) (Ptr + TPB_index);

			/* End of TPB ? */
			if (*(Ptr + TPB_index) == EOTPB)
			{
				/* Yes -> Next TPB */
				Handle = Current_TPB->Next_handle;
				if (!Handle)
					break;

				MEM_Free_pointer(Current_TPB_handle);
				Current_TPB_handle = Handle;
				Ptr = MEM_Claim_pointer(Current_TPB_handle);
				Current_TPB = (struct TPB *) Ptr;

				TPB_index = sizeof(struct TPB);
				Line = (struct Line_info *) (Ptr + TPB_index);
			}
		}

		MEM_Free_pointer(Current_TPB_handle);
	}

	/* Restore clip area */
	memcpy(&(OPM->clip), &Old, sizeof(struct BBRECT));
}

/*
 *****************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Erase_print_area
 * FUNCTION  : Erase the print area.
 * FILE      : TEXTMNG.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 25.08.94 10:46
 * LAST      : 25.08.94 10:46
 * INPUTS    : struct OPM *OPM - Pointer to target OPM.
 * RESULT    : None.
 * BUGS      : No known.
 * SEE ALSO  : TEXT.H
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

void
Erase_print_area(struct OPM *OPM)
{
	struct PA *PA;
	struct Textstyle *Textstyle;
	UNBYTE *Ptr;

	/* Get current PA and text style */
	PA = PA_stack[PA_stack_index];
	Textstyle = Textstyle_stack[Textstyle_stack_index];

	/* Transparent paper ? */
	if (Textstyle->Paper == 0xFFFF)
	{
		/* Yes -> Restore background */
		Ptr = MEM_Claim_pointer(Textstyle_background_handles[Textstyle_stack_index]);
		Put_unmasked_block(OPM, PA->Area.left, PA->Area.top, PA->Area.width,
		 PA->Area.height, Ptr);
		MEM_Free_pointer(Textstyle_background_handles[Textstyle_stack_index]);
	}
	else
	{
		/* No -> Draw paper box */
//		OPM_FillBox(OPM, PA->Area.left, PA->Area.top, PA->Area.width,
//		 PA->Area.height, Textstyle->Paper);
		OPM_FillBox(OPM, 0, 0, PA->Area.width, PA->Area.height,
		 Textstyle->Paper);
	}
}

/*
 *****************************************************************************
 * #FUNCTION HEADER BEGIN#
 * NAME      : Prepare_print_area
 * FUNCTION  : Prepare a print area for printing.
 * FILE      : TEXTMNG.C
 * AUTHOR    : Jurie Horneman
 * FIRST     : 25.08.94 10:55
 * LAST      : 25.08.94 10:55
 * INPUTS    : struct OPM *OPM - Pointer to target OPM.
 * RESULT    : None.
 * BUGS      : No known.
 * SEE ALSO  : TEXT.H
 * #FUNCTION HEADER END#
 */

/* #FUNCTION BEGIN# */

void
Prepare_print_area(struct OPM *OPM)
{
	struct PA *PA;
	struct Textstyle *Textstyle;
	UNBYTE *Ptr;

	/* Get current PA and text style */
	PA = PA_stack[PA_stack_index];
	Textstyle = Textstyle_stack[Textstyle_stack_index];

	/* Transparent paper ? */
	if (Textstyle->Paper == 0xFFFF)
	{
		/* Yes -> Save background */
		Ptr = MEM_Claim_pointer(Textstyle_background_handles[Textstyle_stack_index]);
		Get_block(OPM, PA->Area.left, PA->Area.top, PA->Area.width,
		 PA->Area.height, Ptr);
		MEM_Free_pointer(Textstyle_background_handles[Textstyle_stack_index]);
	}
}

